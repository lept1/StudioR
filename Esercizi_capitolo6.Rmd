---
title: "Esercizi_capitolo5"
author: "Alessandro Dell'Orto"
date: "12/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Functions
<!-- 6 -->

\stepcounter{section}
## Function fundamentals

__[Q1]{.Q}__: Given a name, like `"mean"`, `match.fun()` lets you find a function. Given a function, can you find its name? Why doesn't that make sense in R?
__[A]{.solved}__: in R we can have multiple name for the same function. 

```{r}
## to find the body of a function we can use body() or View()
#View(mean)
body(mean)
args(mean)

## to find the name is not so simple because in the example below functions point to same memory address. so it's not possibile to find the name
#but we can compare two function with identical()
?identical

myfun1 <- function(x) {x}
myfun2 <- myfun1
myfun3 <- myfun1

identical(myfun3,function(x) {x})
identical(myfun3,myfun1)


```



__[Q2]{.Q}__: It’s possible (although typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?

```{r}
function(x) 3()
(function(x) 3)()
```

__[A]{.solved}__: cit. An Anonymous Function (also known as a lambda experssion) is a function definition that is not bound to an identifier. That is, it is a function that is created and used, but never assigned to a variable.
```{r, error = TRUE}
#the first is not correct. its body is 3()
f1 <- function(x) 3()
f1
f1()
```

```{r, error = TRUE}
#the second is correct. its body is 3
f2 <- (function(x) 3)
f2
f2()
```
```{r}
(function(x) x*2)(3)
```

__[Q3]{.Q}__: A good rule of thumb is that an anonymous function should fit on one line and shouldn't need to use `{}`. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?

__[A]{.solved}__: in python i usually used them to modify some dataframe columns.


__[Q4]{.Q}__: What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?
__[A]{.solved}__: 

```{r}

fun1<-function(x) 
        {
         x*2
}
#is.primitive(x) tests if x is a primitive function, i.e, if typeof(x) is either "builtin" or "special".

is.function(1)
is.function(fun1)
is.primitive(fun1)
is.primitive(is.function)
```


__[Q5]{.Q}__: This code makes a list of all functions in the `{base}` package.
```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
length(funs)

```
Use it to answer the following questions:
a. Which base function has the most arguments?
b. How many base functions have no arguments? What's special about those functions?
c. How could you adapt the code to find all primitive functions?  

__[A]{.solved}__: a.  `formals()`

    ```{r, message = FALSE}
    ?formals
    narg<-c()
    for (fun in funs){
      narg<-c(narg,length(formals(fun)))
    }
    names(narg)<-names(funs)
    #print(narg)
    names(narg[narg==max(narg)])
    
    
    #n_args <- funs %>% 
     # map(formals) %>%
     # map_int(length)
    ```
b. 
    ```{r}
    sum(narg == 0)
    ```

c. simply
    ```{r}
    funs <- Filter(is.primitive, objs)
    length(funs)
    ```
__[Q6]{.Q}__: What are the three important components of a function?
__[A]{.solved}__:`body()`, `formals()` & `environment()`


__[Q7]{.Q}__: When does printing a function not show what environment it was created in?
__[A]{.solved}__: Primitive functions and functions in the global environment


\stepcounter{section}
## Lexical scoping

__[Q1]{.Q}__: What does the following code return? Why? Describe how each of the three `c`’s is interpreted.
```{r, eval = FALSE}
c <- 10
c(c = c)
```
__[A]{.solved}__: a vector with one element 10 and named c


__[Q2]{.Q}__: What are the four principles that govern how R looks for values?

__[A]{.solved}__: R’s lexical scoping follows four primary rules: Name masking, Functions versus variables, A fresh start and Dynamic lookup [cit. AdvR]


__[Q3]{.Q}__: What does the following function return? Make a prediction before running the code yourself.
```{r, eval = FALSE}
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x ^ 2
    }
    f() + 1
  }
  f(x) * 2
}
f(10)
```
__[A]{.solved}__: ((10 ^ 2) + 1) * 2=202. the inner function takes x from the enviroment of the middle function, and the middle from the upper one.


## Lazy evaluation

__[Q1]{.Q}__: What important property of `&&` makes `x_ok()` work?
```{r}
x_ok <- function(x) {
  !is.null(x) && length(x) == 1 && x > 0
}
x_ok(NULL)
x_ok(1)
x_ok(1:3)
```
What is different with this code? Why is this behaviour undesirable here?
```{r}
x_ok <- function(x) {
  !is.null(x) & length(x) == 1 & x > 0
}
x_ok(NULL)
x_ok(1)
x_ok(1:3)
```
__[A]{.solved}__: Operators `&` and `|` perform element-wise operation producing result having length of the longer operand. But `&&` and `||` examines only the first element of the operands resulting into a single length logical vector.



__[Q2]{.Q}__: What does this function return? Why? Which principle does it illustrate?

```{r, eval = FALSE}
f2 <- function(x = z) {
  z <- 100
  x
}
f2()
```
__[A]{.solved}__: The function returns 100. In R, function arguments are lazily evaluated: they’re only evaluated if accessed. [cit. ADVR]



__[Q3]{.Q}__: What does this function return? Why? Which principle does it illustrate?

```{r, eval = FALSE}
y <- 10
f1 <- function(x = {y <- 1; 2}, y = 0) {
  c(x, y)
}
f1()
y
```
__[A]{.solved}__: The function returns `c(2, 1)`.  names defined inside a function mask names defined outside a function [cit. AdvR] so y outside the function is not touched. while y=0 is not taken because we assign y<-1 in {}.



__[Q5]{.Q}__: Explain why this function works. Why is it confusing?
```{r}
show_time <- function(x = stop("Error!")) {
  stop <- function(...) Sys.time()
  print(x)
  x
}
show_time()
```
__[A]{.solved}__:the `stop()` function is masked by `function(...) Sys.time()`.



__[Q6]{.Q}__: How many arguments are required when calling `library()`?
__[A]{.solved}__: `library()` doesn't require any arguments. when no arguments are passed it uploads some default packages

```{r}
?library
library()
formals(library)
```




## `...` (dot-dot-dot)

__[Q1]{.Q}__: Explain the following results:
```{r}
sum(1, 2, 3)
mean(1, 2, 3)

sum(1, 2, 3, na.omit = TRUE)
mean(1, 2, 3, na.omit = TRUE)
```
__[A]{.solved}__: Let's look at the guide:
```{r}

?sum #sum returns the sum of all the values present in its arguments.
sum(1, 2, 3, na.omit = TRUE)
sum(1, 2, 3, na.omit = FALSE)# in this case the condition is coerced to numeric

?mean #Generic function for the (trimmed) arithmetic mean. Default S3 method: mean(x, trim = 0, na.rm = FALSE, ...)
mean(x=1, trim=2, na.rm=3)
mean(x=1, trim=2, na.rm=3, na.omit = TRUE)
## in this case na.omit = TRUE is ignored
```



## Exiting a function
__[Q1]{.Q}__: What does `load()` return? Why don’t you normally see these values?
__[A]{.solved}__: 
```{r}
?load  #Reload datasets written with the function save.
?save  #save writes an external representation of R objects to the specified file. The objects can be read back from the file at a later date by using the function load or attach (or data in some cases).
```


__[Q2]{.Q}__: What does `write.table()` return? What would be more useful?

__[A]{.solved}__: `write.table()` writes an object, usually a data frame or a matrix, to disk. The function invisibly returns `NULL`. 
```{r}
?write.table  #write.table prints its required argument x (after converting it to a data frame if it is not one nor a matrix) to a file or connection.

```


## Function forms
__[Q1]{.Q}__: Rewrite the following code snippets into prefix form:

```{r, eval = FALSE}
1 + 2 + 3

1 + (2 + 3)

if (length(x) <= 5) x[[5]] else x[[1]]
```
__[A]{.solved}__:
```{r, eval = FALSE}
`+`(`+`(1, 2), 3)
`+`(1, `+`(2, 3))
`if`(`<=`(length(x), 5), `[[`(x, 5), `[[`(x, 1))
```




__[Q3]{.Q}__: Explain why the following code fails:
```{r, eval = FALSE}
modify(get("x"), 1) <- 10
#> Error: target of assignment expands to non-language object
```
__[A]{.solved}__: First, let's define `x` and recall the definition of `modify()` from *Advanced R*:

```{r}
x <- 1:5
`modify<-` <- function(x, idx, value) {
  x[idx] <- value
  x
}
modify(get("x"), 1) <- 10

```
These errors occur when you try to assign a value to a variable that doesn't exist, or that R can't treat as a name.
```{r, eval = FALSE}
get("x") <- 10
```
we can use 
```{r, eval = FALSE}
assign("x", 10)
x
```
or simply
```{r, eval = FALSE}
x<-1:5
modify(x, 1) <- 123
x
```



__[Q4]{.Q}__: Create a replacement function that modifies a random location in a vector.
__[A]{.solved}__: :
```{r, eval = FALSE}
`modify<-` <- function(x, value) {
  x[sample(length(x),1)] <- value
  x
}

for (i in 1:3){
x<-1:10
modify(x) <- 1123
print(x)
}
```



__[Q5]{.Q}__: Write your own version of `+` that pastes its inputs together if they are character vectors but behaves as usual otherwise. In other words, make this code work:
```{r, eval = FALSE}
1 + 2
#> [1] 3
"a" + "b"
#> [1] "ab"
```
__[A]{.solved}__: let's rewrite `+`
```{r}
`+` <- function(m, n) {
  if (is.character(m) && is.character(n)) {
    paste0(m, n)
  } else {
    base::`+`(m, n)
  }
}


1 + 2
"a" + "b"


# Restore the original `+`
rm(`+`)
```



__[Q6]{.Q}__: Create a list of all the replacement functions found in the `{base}` package. Which ones are primitive functions? (Hint use `apropos()`)
__[A]{.solved}__: 
```{r}
?apropos #we can find object by partial name
repl_fun <- apropos("<-", where = TRUE, mode = "function")
head(repl_fun,10)
```
10 is  the positions on the search path. if we look at search() we see that base functions are at the position 10.
```{r}
search()
```
so we can take only base functions

```{r}
repl_base <- repl_fun[names(repl_fun) == 10]
head(repl_base,10)
```
use pipe with `mget()` --- `Filter()` --- `is.primitive()`.
```{r}
library(magrittr)
repls_base_prim <- mget(repl_base, envir = baseenv()) %>%
  Filter(is.primitive, .) %>% 
  names()
repls_base_prim
```

__[Q7]{.Q}__: What are valid names for user-created infix functions?
__[A]{.solved}__: they can contain any sequence of characters except “%” [cit. AdvR]



__[Q8]{.Q}__: Create an infix `xor()` operator.

__[A]{.solved}__: let's create `%xor%`:

```{r}
`%xor%` <- function(x, y) {
  xor(x, y)
}
TRUE %xor% TRUE
FALSE %xor% TRUE
```


__[Q9]{.Q}__: Create infix versions of the set functions `intersect()`, `union()`, and `setdiff()`. You might call them `%n%`, `%u%`, and `%/%` to match conventions from mathematics.

__[A]{.solved}__: 
```{r}
`%n%` <- function(a, b) {
  intersect(a, b)
}

`%u%` <- function(a, b) {
  union(a, b)
}

`%/%` <- function(a, b) {
  setdiff(a, b)
}

x <- c("a", "b", "d")
y <- c("a", "c", "d")

x %u% y
x %n% y
x %/% y
```